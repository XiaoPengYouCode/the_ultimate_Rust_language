# 什么是所有权

**Rust 之所以能成为万众瞩目的语言，就是因为其内存安全性**

管理运行时使用计算机内存的三种方式

- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

所有权是 Rust 语言的特性，在本章，我们侧重于通过 `字符串` 来引导讲解所有权的相关知识

#### 2.3.1.1 从 c 语言说起

```rust
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

变量 `a` 和 `c` 都是局部变量，函数结束后将局部变量 `a` 的地址返回，但局部变量 `a` 存在栈中，在离开作用域后，`a` 所申请的栈上内存都会被系统回收，从而造成了 `悬空指针(Dangling Pointer)` 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在

再来看变量 `c`，`c` 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 `"xyz"` 只有当整个程序结束后系统才能回收这片内存

#### 2.3.1.2 栈(Stack)和堆(Heap)

栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间

##### 栈

栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**，例如叠盘子。增加数据叫做**进栈**，移出数据则叫做**出栈**。因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间。

##### 堆

与栈不同，编译时对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)

接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据

##### 性能

- 写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

- 读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

因此，处理器处理分配在栈上数据会比在堆上的数据更加高效

调用函数的过程

1. 传递给函数的参数被一次压入栈中

2. 函数结束后，值再依次出栈

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障

## 4.1.2 所有权规则

理解了堆栈，接下来看一下*关于所有权的规则*，首先请谨记以下规则：

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者

2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者

3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

## 4.1.3 变量作用域

作用域是一个项（item）在程序中有效的范围，例如

```rust
let s = "Hello";
```

变量 `s` 绑定了一个字符串字面值，字符串字面值是被硬编码进程序代码中的。此处 `s` 变量从声明处开始，直到当前作用域结束前都是有效的，例如

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的
    ... // 使用 s
}                      // 此作用域已结束，s不再有效
```

综合来看，有两个重要的时间点

1. 当一个变量进入（被创建）作用域，他开始有效

2. 变量离开作用域之前，持续有效

## 4.1.4 `String` 类型

我们在此处需要一个更复杂的数据类型来更好的说明所有权系统的工作模式，这是因为前面所述的数据类型都具有已知的长度，进而可以被存储在栈上，其各种操作也已经明确了，但是我们现在需要探索 Rust 如何管理存储在堆上的内存，`String` 是一个好的例子

本节注重通过 `String` 来了解所有权系统，更多 `String` 相关的内容将会在之后介绍

我们已经见过字符串字面值 `let s ="hello"`，`s` 是被硬编码进程序里的字符串值（类型为 `&str` ）。

字符串字面值是很方便的，但是它并不适用于所有场景，如

- 字符串字面值是不可变的，它被硬编码在程序代码中（如果需要发生编码，就需要硬编码多个字符串，这种做法并不经济）

- 并非所有的字符串的值都能在编写代码的时候得知（用户使用时输入或者运行中途生成）

为此，Rust 设计了 `String` 类型，这种类型被分配在堆上，通过设计，所以能够动态的伸缩，也可以存储编译时未知大小的文字

我们可以通过以下方式创建 `String`

1. 基于字符串字面值创建 `String`。`::` 是一种调用操作符，这里表示调用 `String` 中的 `from` 方法

   ```rust
   let s = String::from("Hello");
   ```

2. 创建空 `String`

   ```rust
   let s = String::new();
   ```

因为 `String` 被存储在堆上，意味着 `String` 可以声明为可变的，并且可以被修改

```rust
let mut s = String("Hello");
s.push_str(", Rust!");  // 在字符串 s 后追加字符串
```

那么这里有什么区别呢？为什么 `String` 可变而字面值却不行呢？区别在于两个类型对内存的处理上

## 内存与分配

就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变

对于 `String` 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

- 必须在运行时向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法。

第一部分由我们完成：当调用 `String::from` 时，它的实现 (*implementation*) 请求其所需的内存。这在编程语言中是非常通用的。

然而，第二部分实现起来就各有区别了。在有 **垃圾回收**（*garbage collector*，*GC*）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 `allocate` 配对一个 `free`

Rust 采取的策略是：内存在拥有它的变量离开作用域后就被自动释放

下面是一个 `String` 的有关作用域的例子

```rust
{
    let s = String::from("hello"); // 从此处起，s 是有效的
    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
```

这是一个将 `String` 需要的内存返回给分配器的很自然的位置：当 `s` 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)，在这里 `String` 的作者可以放置释放内存的代码。Rust 在结尾的 `}` 处自动调用 `drop`

这个模式有着很重要的作用，在复杂场景下代码的行为可能是不可预测的，下面我们来看以下场景

`String` 由三部分组成，如图所示：

1. 一个指向存放字符串内容内存的指针

2. 一个长度，表示 `String` 的内容当前使用了多少字节的内存

3. 一个容量，表示 `String` 从分配器总共获取了多少字节的内存

这一组数据存储在栈上。右侧则是堆上存放内容的内存部分

### 变量与数据交互的方式（一）移动

Rust 中，多个变量可以采用不同的方式和同一个数据进行交互，看下面这个整数的例子

```rust
let x = 5;
let y = x;
```

代码背后的逻辑很简单, 将 `5` 绑定到变量 `x`；接着拷贝 `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`

因为整数是 Rust 基本数据类型，是固定大小的简单值，因此所有的数据都被存在栈中，完全无需在堆上分配内存。

但是

```rust
let s1 = String::from("hello");
let s2 = s1;
```

有两种可能的情况

1. 拷贝 `String` 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 `String` 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响

2. 只拷贝 `String` 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 `8字节的指针`、`8字节的长度`、`8字节的容量`，总计 24 字节，速度更快

目前看来 2 更好一些，但是违反了所有权规则 **一个值只允许有一个所有者**，而现在存储在堆上的字符串字面值有了两个所有者：`s1` 和 `s2`，这样会导致对应的内存被重复释放，这将会导致内存污染，出现隐藏的安全漏洞

我尝试了以下，如果在 c++ 中重复释放内存，可以过编译但是无法正确执行

Rust 的解决方式是，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效，因此 Rust 不需要在 `s1` 离开作用域后清理任何东西。如果我们尝试在此之后使用 `s1`，如

```rust
let s1 = String::from("Hello");
let s2 = s1;
println!("s1 = {}", s1);
```

将无法通过编译

如果您在使用其他语言时听说过“浅拷贝”和“深拷贝”这两个术语，那么在不复制数据的情况下复制指针、长度和容量的概念可能听起来像是制作浅拷贝。但是由于 Rust 也使第一个变量失效，因此它被称为 move（移动），而不是称为浅拷贝。在此示例中，我们会说它被 `s1` 移动到 `s2`

总之，这样解决了我们的问题，只有 `s2` 有效，当他超出作用域时他就会释放内存

此外，这还隐含着一个设计选择：Rust 永远不会自动创建数据的“深度”副本。因此，就运行时性能而言，可以假定任何自动复制都是廉价的

### 变量与数据交互的方式（二）克隆

如果我们确实需要复制 `String` 在堆上的数据，我们可以使用一个通用函数 `clone`，例如

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}", s1);
```

这里，`s1` 在堆上的数据内容也被复制了，所有仍然有效，代码能够正常运行

当看到调用了 `clone` 方法时，你应该意识到大致会执行什么功能，并且这种功能可能会相当消耗资源

### 只存储在栈上的数据：Copy

对之前的例子，

```rust
let x = 5;
let y = x;
println!("x = {}", x);
```

对于这种已知长度的可以存储在栈上，所以及时我们并没有调用 `clone` 方法，`x` 变量在此处依旧有效，不会被移动到 `y` 中，这里没有深拷贝和浅拷贝的区别

Rust 有一个特殊注解叫做 copy trait，这个注解作用于数据类型，如果一个类型实现了 copy trait，那么旧的变量赋值给其他变量之后依旧可用

Rust 不允许自身或者任何部分实现了 Drop trait 的类型使用 copy trait，如果我们对其值离开作用域时需要特殊处理的类型使用了 copy 注解，会得到一个编译时错误。

一般来说，任何一组简单标量值的组合都可以实现 Copy，如下是一些 Copy 的类型

- 所有整数类型，比如 u32。
- 布尔类型，bool，它的值是 true 和 false。
- 所有浮点数类型，比如 f64。
- 字符类型，char。
- 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。

### 所有权与函数

返回值可以转移所有权，例如叠盘子

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中，
                                        // 它也将返回值移给 s3
} // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 离开作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 会将
                                             // 返回值移动给
                                             // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域
    some_string                              // 返回 some_string
                                             // 并移出给调用的函数
                                             //
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
                                                      //

    a_string  // 返回 a_string 并移出给调用的函数
}
```

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。

我们可以使用元组来返回多个值，如示例 4-5 所示

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
```

但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 引用（references）

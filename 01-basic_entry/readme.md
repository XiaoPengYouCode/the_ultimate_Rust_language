# Rust 基础入门

一些将会接触到的之前从没接触过的概念

- 所有权、借用、生命周期
- 宏编程
- 模式匹配

本章主要介绍 Rust 的基础语法、数据类型、项目结构等

一段基础的代码

```rust
// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值
fn main() {
    // 使用let来声明变量，进行绑定，a是不可变的
    // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
    // 语句的末尾必须以分号结尾
    let a = 10;
    // 主动指定b的类型为i32
    let b: i32 = 20;
    // 这里有两点值得注意：
    // 1. 可以在数值中带上类型:30i32表示数值是30，类型是i32
    // 2. c是可变的，mut是mutable的缩写
    let mut c = 30i32;
    // 还能在数值和类型中间添加一个下划线，让可读性更好
    let d = 30_i32;
    // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数
    let e = add(add(a, b), add(c, d));

    // println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块
    // 该函数将指定的格式化字符串输出到标准输出中(控制台)
    // {}是占位符，在具体执行过程中，会把e的值代入进来
    println!("( a + b ) + ( c + d ) = {}", e);
}

// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和
fn add(i: i32, j: i32) -> i32 {
    // 返回相加值，这里可以省略return
    // 没有return时，不要为 i+j 添加 ;，这会改变语法导致函数返回 () 而不是 i32
    // 详见语句和表达式
    i + j
}
```

有几点可以留意下：

- 字符串使用双引号 `""` 而不是单引号 `''`，Rust 中单引号是留给单个字符类型（`char`）使用的
- Rust 使用 `{}` 来作为格式化输出占位符，由于 `println!` 会自动推导出具体的类型，因此无需手动指定

## 2.1 变量的绑定与解构

### 2.1.1 为什么 Rust 要手动设定变量的可变性？

- 满足灵活性（可变）与安全性（不可变）

- 减少运行时检查，增加代码性能

### 2.1.2 变量命名规范

[rust-rfcs]([rfcs/text/0430-finalizing-naming-conventions.md at master · rust-lang/rfcs (github.com)](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md)) 是 Rust 官方的一套命名规范

通常，对于 **type-level** 的构造 Rust 倾向于使用**驼峰命名法**，而对于 **value-level** 的构造使用**蛇形命名法**。详情如下：

- 对于**驼峰命名法**，复合词的缩略形式我们认为是一个单独的词语，所以**只对首字母进行大写**：使用 `Uuid` 而不是 ~~`UUID`~~，`Usize` 而不是 ~~`USize`~~，`Stdin` 而不是 ~~`StdIn`~~。

- 对于**蛇形命名法**，缩略词用全小写：`is_xid_start`。

- 对于**蛇形命名法**（包括全大写的 `SCREAMING_SNAKE_CASE`），除了最后一部分，其它部分的词语都不能由**单个字母**组成： `btree_map` 而不是 ~~`b_tree_map`~~，`PI_2` 而不是 ~~`PI2`~~.

- 包名**不应该**使用 `-rs` 或者 `-rust` 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。

### 2.1.3 变量绑定

在 Rust 中，我们这样写： `let a = "hello world"` ，同时给这个过程起了另一个名字：**变量绑定**

> 为什么使用”绑定“而不是其他语言传统中的“赋值”呢
> 
> > （其实你也可以称之为赋值，但是绑定的含义更清晰准确）？这里就涉及 Rust 最核心的原则——**所有权**，简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为该对象的主人（聪明的读者应该能猜到，在这种情况下，该对象之前的主人就会丧失对该对象的所有权），像极了我们的现实世界，不是吗？
> > 
> > 那为什么要引进“所有权”这个新的概念呢？请稍安勿躁，时机一旦成熟，我们就回来继续讨论这个话题。

### 2.1.4 变量与可变性

首先，变量默认不可变，这样可以增加更多的安全性和性能

我们可以在定义变量时使用 `mut` 关键字来让变量具有可变性，这样设计更加灵活

如果变量 `a` 不可变，那么一旦为它绑定值，就不能再修改 `a` ，否则会报错

```rust
fn main() {
    let a = 5;
    a = 6; // Error! Cannot assign twice to immutable variable a!
}
```

这种错误是为了避免无法预期的错误发生在我们的变量上：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。

这种规则让我们的代码变得非常清晰，只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。

但是可变性也非常重要，否则我们就要像 ClojureScript 那样，每次要改变，就要重新生成一个对象，在拥有大量对象的场景，性能会变得非常低下，内存拷贝的成本异常的高。

在 Rust 中，可变性很简单，只要在变量名前加一个 `mut` 即可, 而且这种显式的声明方式还会给后来人传达这样的信息：嗯，这个变量在后面代码部分会发生改变

```rust
fn main() {
    let mut a = 5;
    a = 6; // The value 6 is assigned to variable a now!
}
```

选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。而可变变量最大的好处就是使用上的灵活性和性能上的提升。

例如，在使用大型数据结构或者热点代码路径（被大量频繁调用）的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能会更容易理解，所以值得以较低的性能开销来确保代码清晰

### 2.1.5 使用下划线开头忽略未使用的变量

如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时**你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头**：

```rust
fn main() {
    let _x = 5;
    let y = 10; // Warning! Unused_variables!
}
```

使用 `cargo run` 运行下试试:

可以看到，两个变量都是只有声明，没有使用，但是编译器却独独给出了 `y` 未被使用的警告，充分说明了 `_` 变量名前缀在这里发挥的作用。

值得注意的是，这里编译器还很善意的给出了提示( Rust 的编译器非常强大，这里的提示只是小意思 ): 将 `y` 修改 `_y` 即可。这里就不再给出代码，留给大家手动尝试并观察下运行结果。

更多关于 `_x` 的使用信息，请阅读后面的模式匹配章节中讲

### 2.1.6 变量解构

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b); // 断言
}
```

这里 `{:?}` 打印占位符是一种特殊占位符，详见这篇文章 [println! 的各种用法](https://blog.csdn.net/lizhe_dashuju/article/details/108108167)

#### 2.1.6.1 解构式赋值

在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了

```rust
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，而不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```

这种使用方式跟之前的 `let` 保持了一致性，但是 `let` 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值

- `_` 代表匹配一个值，而不关心具体的值是什么

- `..` 代表匹配多个值，而不关心具体的内容

更多内容详见 [2909-destructuring-assignment](https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html) 中的详细阐述

需要注意的是，使用 `+=` 的赋值语句还不支持解构式赋值。

> 这里用到了模式匹配的一些语法，如果大家看不懂没关系，可以在学完模式匹配章节后，再回头来看。

### 2.1.7 变量和常量的差异

变量的值不能更改可能让你想起其他另一个很多语言都有的编程概念：**常量**(*constant*)。与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：

- 常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值
- 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注

下面是一个常量声明的例子，其常量名为 `MAX_POINTS`，值设置为 `100,000`。（Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性）：

`const MAX_POINTS: u32 = 100_000;`

常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用，例如游戏中允许玩家赚取的最大点数或光速

> 在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可

### 2.1.8 变量遮蔽

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：

```rust
fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```

这个程序首先将数值 `5` 绑定到 `x`，然后通过重复使用 `let x =` 来遮蔽之前的 `x`，并取原来的值加上 `1`，所以 `x` 的值变成了 `6`。第三个 `let` 语句同样遮蔽前面的 `x`，取之前的值并乘上 `2`，得到的 `x` 最终值为 `12`。当运行此程序，将输出以下内容：

```shell
The value of x in the inner scope is: 12
The value of x is: 6
```

这和 `mut` 变量的使用是不同的，第二个 `let` 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 `mut` 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好

例如，假设有一个程序要统计一个空格字符串的空格数量：

```rust
// 字符串类型
let spaces = "   ";
// usize
let spaces = spaces.len();
```

这种结构是允许的，因为第一个 `spaces` 变量是一个字符串类型，第二个 `spaces` 变量是一个全新的变量且和第一个具有相同的变量名，且是一个数值类型。所以变量遮蔽可以帮我们节省些脑细胞，不用去想如 `spaces_str` 和 `spaces_num` 此类的变量名；相反我们可以重复使用更简单的 `spaces` 变量名。如果你不用 `let` :

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

运行一下，你就会发现编译器会报错

```shell
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error
```

显然，Rust 对类型的要求很严格，不允许将整数类型 `usize` 赋值给字符串类型 `&str` 。`usize` 是一种 CPU 相关的整数类型，在之后数值类型中有详细介绍

# 万事开头难！

## 2.2 基本类型

当一门语言不谈类型时，你得小心，这大概率是动态语言(别拍我，我承认是废话)。但是把类型大张旗鼓的用多个章节去讲的，Rust 是其中之一。

Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。

基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型(一般意义上来说)，由以下组成：

- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true` 和 `false`
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元（unit）类型: 即 `()` ，其唯一的值也是 `()`

### 2.2.0 类型推导与标注

与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 **Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注

来看段代码：

```rust
let guess = "42".parse().expect("Not a number!");
```

先忽略 `.parse().expect..` 部分，这段代码的目的是将字符串 `"42"` 进行解析，而编译器在这里无法推导出我们想要的类型：整数？浮点数？字符串？因此编译器会报错：

```shell
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
```

因此我们需要提供给编译器更多的信息，例如给 `guess` 变量一个**显式的类型标注**：

- `let guess: i32 = ...` 或者 `"42".parse::<i32>()`

### 2.2.1 数值类型

首先，Rust 的简单数值类型和其他语言中别无致，而且也支持各种数值运算

而 Rust 同时也支持为复杂的数据类型定义新的复杂数值运算，也就是所谓的运算符重载

#### 2.2.1.1 整数类型

**整数**是没有小数部分的数字。之前使用过的 `i32` 类型，表示有符号的 32 位整数（ `i` 是英文单词 *integer* 的首字母，与之相反的是 `u`，代表无符号 `unsigned` 类型）。下表显示了 Rust 中的内置的整数类型：

| 长度    | 有符号类型   | 无符号类型   |
| ----- | ------- | ------- |
| 8 位   | `i8`    | `u8`    |
| 16 位  | `i16`   | `u16`   |
| 32 位  | `i32`   | `u32`   |
| 64 位  | `i64`   | `u64`   |
| 128 位 | `i128`  | `u128`  |
| 视架构而定 | `isize` | `usize` |

类型定义的形式统一为：`有无符号 + 类型大小(位数)`。**无符号数**表示数字只能取正数和0，而**有符号**则表示数字可以取正数、负数还有0。

当要强调符号时，数字前面可以带上正号或负号。

有符号数字以[补码](https://en.wikipedia.org/wiki/Two%27s_complement)形式存储。

每个有符号类型规定的数字范围是 $-2^{n - 1}$~ $ 2^{n - 1}$ - 1，其中 `n` 是该定义形式的位长度。因此 `i8` 可存储数字范围是 -$2^7$ ~ $2^7$ - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 `u8` 能够存储的数字为 0 ~ $2^8$-1，即 0 ~ 255

此外，`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位

整形字面量可以用下表的形式书写：

| 数字字面量         | 示例             |
| ------------- | -------------- |
| 十进制           | `98_222`       |
| 十六进制          | `0xff`         |
| 八进制           | `0o77`         |
| 二进制           | `0b1111_0000`  |
| 字节 (仅限于 `u8`) | `b'A'` (ASCII) |

这么多类型，有没有一个简单的使用准则？答案是肯定的， Rust 整型默认使用 `i32`，例如 `let i = 1;`，那 `i` 就是 `i32` 类型，因此你可以首选它，同时该类型也往往是性能最好的。`isize` 和 `usize` 的主要应用场景是用作集合的索引（集合是一种复合数据类型）

##### 整型溢出（overflow）

假设有一个 `u8` ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生**整型溢出**。

关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 *panic* (崩溃, Rust 使用这个术语来表明程序因错误而退出)

在使用 `cargo check` 时，默认不会对溢出进行检查，因为这不是一个编译错误，而是一个程序错误，`cargo check` 默认只检查编译错误

在当使用 `--release` 参数进行 release 模式构建时，Rust **不**检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（*two’s complement wrapping*）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 `u8` 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 *panic*，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法使值达到最小值或最大值

下面是一个演示 `wrapping_*` 方法的示例：

```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

#### 2.2.1.2 浮点类型

**浮点类型数字** 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高

下面是一个演示浮点数的示例：

```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

浮点数根据 `IEEE-754` 标准实现

- `f32` 类型是单精度浮点型

- `f64` 为双精度浮点型

##### 浮点数陷阱

浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：

1. **浮点数往往是你想要数字的近似表达** 
   
   1. 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性。
   
   2. 更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行

2. **浮点数在某些特性上是反直觉的** 
   
   1. 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 `f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：
      
      - Rust 的 `HashMap` 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 `K` 没有特定类型的限制，但是要求能用作 `K` 的类型必须实现了 `std::cmp::Eq` 特征，因此这意味着你无法使用浮点数作为 `HashMap` 的 `Key`，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 `HashMap` 的 `Key`。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

```rust
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

你可能以为，这段代码没啥问题吧，实际上它会 *panic*(程序崩溃，抛出异常)，因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差

那如果非要进行比较呢？可以考虑用这种方式 `(0.1_f64 + 0.2 - 0.3).abs() < 0.00001` ，具体小于多少，取决于你对精度的需求

讲到这里，相信大家基本已经明白了，为什么操作浮点数时要格外的小心，但是还不够，下面再来一段代码，直接震撼你的灵魂：

```rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

运行该程序，输出如下:

```shell
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

仔细看，对 `f32` 类型做加法时，`0.1 + 0.2` 的结果是 `3e99999a`，`0.3` 也是 `3e99999a`，因此 `f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化，`0.1 + 0.2` 以 `4` 结尾，但是 `0.3` 以`3`结尾，这个细微区别导致 `f64` 下的测试失败了，并且抛出了异常。

是不是**blow your mind away**? 没关系，在本书的后续章节中类似的直击灵魂的地方还很多，这就是敢号称 `Rust语言圣经（Rust Course）` 的底气！

#### 2.2.1.3 NaN(Not a number)

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，下面的代码会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN`s

```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

#### 2.2.1.4 数值运算

加减乘除余

计算过程

1. 数值表达式进行计算

2. 计算结果绑定在变量上

一个综合性例子

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

#### 2.2.1.5 位运算

Rust的位运算基本上和其他语言一样

| 运算符   | 说明                           |
|:-----:|:----------------------------:|
| & 位与  | 相同位置均为1时则为1，否则为0             |
| \| 位或 | 相同位置只要有1时则为1，否则为0            |
| ^ 异或  | 相同位置不相同则为1，相同则为0             |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0       |
| << 左移 | 所有位向左移动指定位数，右位补0             |
| >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

```rust
// 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
a <<= b;
```

#### 2.2.1.6 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如

-  `1..5`，生成从 1 到 4 的连续数字，不包含 5

- `1..=5`，生成从 1 到 5 的连续数字，包含5

```rust
for i in 1..=5 {
    println!("{}",i);
}
```

**序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型**

如下是一个使用字符类型序列的例子：

```rust
for ch in 'A'..='Z' {
    println!("{}", ch);
}
```

#### 2.2.1.7 使用 As 完成类型转换

Rust 中可以使用 `As` 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。你可以在[这里](https://course.rs/advance/into-types/converse.html)了解更多相关的知识。

#### 2.2.1.8 有理数和复数

Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

好在社区已经开发出高质量的 Rust 数值库：[num](https://crates.io/crates/num)。

按照以下步骤来引入 `num` 库：

1. 在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = "0.4.0"`

```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```

#### 总结

之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：

- **Rust 拥有相当多的数值类型**. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数
- **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
- **Rust 的数值上可以使用方法**. 例如你可以用以下方法来将 `13.14` 取整：`13.14_f32.round()`，在这里我们使用了类型后缀，因为编译器需要知道 `13.14` 的具体类型

### 2.2.2 字符、布尔、单元类型

#### 2.2.2.1 字符

牛逼的点在于Unicode，而不是ASCII，占用四个字节，同时有一个函数可以查看某个变量使用了多少字节的空间

```rust
fn main() {
    let x = '你';
    println!("字符'你'占用了{}个字节的内存", std::mem::size_of_val(&x));
}
```

运行结果如下

```shell
字符'你'占用了4个字节的内存
```

注意，双引号 `""` 是留给字符串的

#### 2.2.2.2 布尔

布尔类型占用 1 个字节的内存，主要用在控制语句和循环语句中

#### 2.2.2.3 单元类型

单元类型就是 `()`，唯一的值也是 `()`

`main` 函数就会返回一个单元类型，而非无返回值，而 Rust 拥有特定的无返回值函数——发散函数(diverge function)，就是无法收敛的函数，例如在函数中写一个 `panic`

`unit` 的作用

- 函数和宏的返回值

- 用于 map 中的值，这种情况下只关注键(key)不关注值(value)

### 2.2.3 语句和表达式

Rust 的函数体

Rust 的函数体包括一系列语句，最终使用一个表达式来返回值

```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```

语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值

对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**, 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**

#### 2.2.3.1 语句

```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```

以上都是语句，它们完成了一个具体的操作，但是并没有返回值，因此是语句。

由于 `let` 是语句，因此不能将 `let` 语句赋值给其它值，如下形式是错误的：

```rust
let b = (let a = 8);
```

以上的错误告诉我们 `let` 是语句，不是表达式，因此它不返回值，也就不能给其它变量赋值。但是该错误还透漏了一个重要的信息， `let` 作为表达式已经是试验功能了，也许不久的将来，我们在 [`stable rust`](https://course.rs/appendix/rust-version.html) 下可以这样使用

#### 2.2.3.2 表达式

表达式会进行求值，然后返回一个值，比如 `6`，`5 + 6`

表达式可以成为语句的一部分，例如 `let y = 6` 中，`6` 就是一个表达式，它在求值后返回一个值 `6`（有些反直觉，但是确实是表达式）

- 调用一个函数是表达式，因为会返回一个值

- 调用宏也是表达式

- 用花括号包裹最终返回一个值的语句块也是表达式

**总之，能返回值，它就是表达式**

现在看以下特殊情况

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    }; // { ... } 构成一个表达式

    println!("The value of y is: {}", y);
}
```

是一个语句块表达式，它的值是最后一行表达式的值，这整个表达式的值等于最后一行表达式的值，他将被返回，然后赋值给变量 `y`

**表达式不能包含分号**，这一点非常重要，一旦你在表达式后加上分号，它就会变成一条语句，再也**不会**返回一个值，请牢记！

最后，如果表达式不返回任何值，会隐式返回一个 `()`，看下面这个例子

```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```

可以在最后写一行 `println!()`，如果加分号，就是隐式返回了 `unit`，如果不加分号，就是返回了 `println!()` 表达式的返回值，也是 `unit`，两个程序都不会 `panic`

### 2.2.4 函数

这是一个函数的例子（其经典程度不亚于 `helloworld` 程序）

```rust
fn add(i: i32, j: i32) -> i32 {
    i + j
}
```

这个例子虽然小，但是包含了一个函数的所有要素，详见下图

![](https://pic2.zhimg.com/80/v2-54b3a6d435d2482243edc4be9ab98153_1440w.png)

我们娓娓道来

#### 2.2.4.1 相关规范

- 函数名和变量名采用蛇形命名法(snake case)，例如 `add_two`

- 函数的位置随意，而不是像 `c++` 等语言一样需要在代码中调用之前先定义或者声明

#### 2.2.4.2 函数参数

Rust 是强类型语言，所有的**函数参数都需要显式标识出他具体的类型**，例如

```rust
fn main() {
    simple_function(5, 6.1);
}

fn simple_function(x: i32, y: f64) {
    println!("The value of x is :{}", x);
    println!("The value of y is :{}", y);
}
```

任意函数参数如果不标注类型，都无法通过编译

#### 2.2.4.3 函数返回

函数的返回值就是函数体最后一条表达式的返回值

Rust 中函数是表达式，所以我们可以把函数的返回值直接赋给一个变量，例如

```rust
fn main() {
    let ans = plus_five(5);
}

fn plus_five(i: i32) {
    i + 5
}
```

这里 `i + 5` 是一个表达式，`main` 函数中调用这个函数，返回值与变量 `ans` 绑定

我们也可以使用 `return` 提前返回返回值

```rust
fn plus_or_minus(x:i32) -> i32 {
    if x > 5 {
        return x - 5
    }

    x + 5
}

fn main() {
    let x = plus_or_minus(5);

    println!("The value of x is: {}", x);
}
```

`plus_or_minus` 函数根据传入 `x` 的大小来决定是做加法还是减法，若 `x > 5` 则通过 `return` 提前返回 `x - 5` 的值，否则返回 `x + 5` 的值

#### 2.2.4.4 其他特殊返回类型

##### 无返回值 ()

例如单元类型 `()`，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：

- 函数没有返回值，那么默认返回一个 `()`
- 通过 `;` 结尾的表达式默认返回一个 `()`

函数也可以显式地返回一个 `()`

##### 发散函数(diverging function)

使用 `!` 作为函数返回值类型的时候，表示该函数发散，通常有以下两个用处

1. 用在导致程序崩溃的函数，如
   
   ```rust
   fn dead_end() -> ! {
       ...
       panic!("Disaster!");
   }
   ```

2. 函数中有一个永不跳出的无限循环
   
   ```rust
   fn forever() -> ! {
       loop {
           ...
       };
   }
   ```

## 2.3 ❤️所有权系统❤️

**Rust 之所以能成为万众瞩目的语言，就是因为其内存安全性**

在以往，内存安全几乎都是通过 GC(garbage collecter) 的方式实现，但是 GC 会引来性能、内存占用以及 Stop the world 等问题，在高性能场景和系统编程上是不可接受的，因此 Rust 采用了与(错)众(误)不(之)同(源)的方式：**所有权系统**

### 2.3.1 所有权

释放申请内存空间的三种方式

- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

在本章，我们将通过 `字符串` 来引导讲解所有权的相关知识

#### 2.3.1.1 从 c 语言说起

```rust
int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = "xyz";   // 变量c的作用域开始
    return &a;
}                   // 变量a和c的作用域结束
```

变量 `a` 和 `c` 都是局部变量，函数结束后将局部变量 `a` 的地址返回，但局部变量 `a` 存在栈中，在离开作用域后，`a` 所申请的栈上内存都会被系统回收，从而造成了 `悬空指针(Dangling Pointer)` 的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误, 很多编程语言都存在

再来看变量 `c`，`c` 的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不再会使用这个字符串，但 `"xyz"` 只有当整个程序结束后系统才能回收这片内存

#### 2.3.1.2 栈(Stack)和堆(Heap)

栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间

##### 栈

栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**，例如叠盘子

增加数据叫做**进栈**，移出数据则叫做**出栈**。

因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。

##### 堆

与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)

接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据

由上可知，堆是一种缺乏组织的数据结构

##### 性能

- 写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

- 读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

因此，处理器处理分配在栈上数据会比在堆上的数据更加高效。

##### 所有权和堆栈

调用函数的过程

1. 传递给函数的参数被一次压入栈中

2. 函数结束后，值再依次出栈

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障

#### 2.3.1.3 所有权原则

理解了堆栈，接下来看一下*关于所有权的规则*，首先请谨记以下规则：

> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

##### 变量作用域

作用域是一个变量在程序中有效的范围，例如

```rust
let s = "Hello";
```

变量 `s` 绑定了一个字符串字面值，字符串字面值是被硬编码进程序代码中的

此处 `s` 变量从声明处开始，直到当前作用域结束前都是有效的，例如

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从此处起，s 是有效的
    ... // 使用 s
}                      // 此作用域已结束，s不再有效
```

##### `String` 类型

我们已经见过字符串字面值 `let s ="hello"`，`s` 是被硬编码进程序里的字符串值（类型为 `&str` ）。

字符串字面值是很方便的，但是它并不适用于所有场景，如

- 字符串字面值是不可变的，它被硬编码在程序代码中（如果需要发生编码，就需要硬编码多个字符串，这种做法并不经济）

- 并非所有的字符串的值都能在编写代码的时候得知（用户使用时输入或者运行中途生成）

为此，Rust 设计了 `String` 类型，这种类型被分配在堆上，通过设计，所以能够动态的伸缩，也可以存储编译时未知大小的文字

我们可以通过以下方式创建 `String`

1. 基于字符串字面值创建 `String`。`::` 是一种调用操作符，这里表示调用 `String` 中的 `from` 方法
   
   ```rust
   let s = String::from("Hello");
   ```

2. 创建空 `String`
   
   ```rust
   let s = String::new();
   ```

因为 `String` 被存储在堆上，意味着 `String` 可以声明为可变的，并且可以被修改

```rust
let mut s = String("Hello");
s.push_str(", Rust!");  // 在字符串 s 后追加字符串
```

##### Rust 中 String 的内幕

`String` 由三部分组成，如图所示：

<img title="" src="file:///C:/Users/luzho/AppData/Roaming/marktext/images/2023-11-26-01-39-39-image.png" alt="" width="246" data-align="center">

1. 一个指向存放字符串内容内存的指针

2. 一个长度，表示 `String` 的内容当前使用了多少字节的内存

3. 一个容量，表示 `String` 从分配器总共获取了多少字节的内存

这一组数据存储在栈上。右侧则是堆上存放内容的内存部分

#### 2.3.1.4 变量绑定的数据交互

##### 转移所有权

先来看一段代码：

```rust
let x = 5;
let y = x;
```

代码背后的逻辑很简单, 将 `5` 绑定到变量 `x`；接着拷贝 `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。

可能有同学会有疑问：这种拷贝不消耗性能吗？实际上，这种栈上的数据足够简单，而且拷贝非常非常快，只需要复制一个整数大小（`i32`，4 个字节）的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。实际上，上一章我们讲到的 Rust 基本类型（存储在栈上）都是通过自动拷贝的方式来赋值的，就像上面代码一样。

但是

```rust
let s1 = String::from("hello");
let s2 = s1;
```

有两种可能的情况

1. 拷贝 `String` 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 `String` 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响

2. 只拷贝 `String` 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 `8字节的指针`、`8字节的长度`、`8字节的容量`，总计 24 字节，速度更快

目前看来 2 更好一些，但是违反了所有权规则 **一个值只允许有一个所有者**，而现在存储在堆上的字符串字面值有了两个所有者：`s1` 和 `s2`，这样会导致对应的内存被重复释放，这将会导致内存污染，出现隐藏的安全漏洞

我尝试了以下，如果在 c++ 中重复释放内存，可以过编译但是无法正确执行

Rust 的解决方式是，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效，因此 Rust 不需要在 `s1` 离开作用域后清理任何东西。如果我们尝试在此之后使用 `s1`，如

```rust
let s1 = String::from("Hello");
let s2 = s1;
println!("s1 = {}", s1);
```

将无法通过编译

如果您在使用其他语言时听说过“浅拷贝”和“深拷贝”这两个术语，那么在不复制数据的情况下复制指针、长度和容量的概念可能听起来像是制作浅拷贝。但是由于 Rust 也使第一个变量失效，因此它被称为 move（移动），而不是称为浅拷贝。在此示例中，我们会说它被 `s1` 移动到 `s2`

总之，这样解决了我们的问题，只有 `s2` 有效，当他超出作用域时他就会释放内存

此外，这还隐含着一个设计选择：Rust 永远不会自动创建数据的“深度”副本。因此，就运行时性能而言，可以假定任何自动复制都是廉价的

#### 
